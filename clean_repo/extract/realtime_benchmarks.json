{"extracted_information": "This guide details the scalability benchmarks for Supabase Realtime's features: Broadcast, Presence, and Postgres Changes. It outlines the methodology, specific workloads tested, and detailed performance results. Key optimization recommendations for Postgres Changes at scale include using a separate 'public' table without Row Level Security (RLS) and filters, or using Realtime server-side only to re-stream changes via Realtime Broadcast. Users are advised to run their own benchmarks and contact support for specific use cases.", "specifications": {"benchmarking_tool": "k6 (open-source load testing tool)", "deployment_environment": "Realtime Cluster deployed on AWS", "cluster_configurations": "2-6 nodes, tested in single-region and multi-region setups, all connected to a single Supabase project", "load_generator_placement": "k6 servers deployed on AWS to minimize network latency", "test_execution_method": "Full load from the start without warm-up runs", "metrics_collected": ["message throughput", "latency percentiles", "CPU utilization", "memory utilization", "connection success rates"], "performance_variation_note": "Performance in production environments may vary based on factors such as network conditions, hardware specifications, and specific usage patterns."}, "pricing": {}, "features": ["Broadcast Performance", "Payload Size Impact on Broadcast", "Large-Scale Broadcasting", "Authentication and New Connection Rate", "Database Events (Postgres Changes)"], "statistics": {"broadcast_using_websockets": {"concurrent_users": "32_000", "total_channel_joins": "64_000", "message_throughput": "224_000 msgs/sec", "median_latency": "6 ms", "latency_p95": "28 ms", "latency_p99": "213 ms", "data_received": "6.4 MB/s (7.9 GB total)", "data_sent": "23 KB/s (28 MB total)", "new_connection_rate": "320 conn/sec", "channel_join_rate": "640 joins/sec", "test_duration": "10 minutes", "messages_per_second_per_vu": "2 messages/sec to each of 2 joined channels"}, "broadcast_using_database": {"concurrent_users": "80_000", "total_channel_joins": "160_000", "message_throughput": "10_000 msgs/sec", "median_latency": "46 ms", "latency_p95": "132 ms", "latency_p99": "159 ms", "data_received": "1.7 MB/s (42 GB total)", "data_sent": "0.4 MB/s (4 GB total)", "new_connection_rate": "2000 conn/sec", "channel_join_rate": "4000 joins/sec", "database_trigger_rate": "10_000 inserts per second"}, "broadcast_impact_of_payload_size": {"test_duration": "5 minutes", "messages_per_second_per_vu": "2 messages/sec to each of 2 joined channels", "1kb_payload": {"concurrent_users": "4_000", "message_throughput": "28_000 msgs/sec", "median_latency": "13 ms", "latency_p95": "36 ms", "latency_p99": "85 ms", "data_received": "31.2 MB/s (10.4 GB)", "data_sent": "9.2 MB/s (3.1 GB)"}, "10kb_payload": {"concurrent_users": "4_000", "message_throughput": "28_000 msgs/sec", "median_latency": "16 ms", "latency_p95": "42 ms", "latency_p99": "93 ms", "data_received": "268 MB/s (72 GB)", "data_sent": "76 MB/s (20.8 GB)"}, "50kb_payload": {"concurrent_users": "4_000", "message_throughput": "28_000 msgs/sec", "median_latency": "27 ms", "latency_p95": "81 ms", "latency_p99": "146 ms", "data_received": "1284 MB/s (348 GB)", "data_sent": "384 MB/s (104 GB)"}, "50kb_payload_reduced_load": {"concurrent_users": "2_000", "message_throughput": "14_000 msgs/sec", "median_latency": "19 ms", "latency_p95": "39 ms", "latency_p99": "82 ms", "data_received": "644 MB/s (176 GB)", "data_sent": "192 MB/s (52 GB)"}}, "broadcast_scalability_scenarios": {"concurrent_users": "250_000", "total_channel_joins": "500_000", "users_per_channel": "100", "message_throughput": ">800_000 msgs/sec", "median_latency": "58 ms", "latency_p95": "279 ms", "latency_p99": "508 ms", "data_received": "68 MB/s (600 GB)", "data_sent": "0.64 MB/s (5.7 GB)", "connection_duration": "30-120 minutes", "messages_per_minute_per_vu": "1 message/minute to each of 2 joined channels", "message_broadcast_to": "100 other users"}, "realtime_auth": {"concurrent_users": "50_000", "total_channel_joins": "100_000", "users_per_channel": "100", "message_throughput": ">150_000 msgs/sec", "new_connection_rate": "500 conn/sec", "channel_join_rate": "1000 joins/sec", "median_latency": "19 ms", "latency_p95": "49 ms", "latency_p99": "96 ms", "connection_duration": "2.5 minutes", "messages_per_minute_per_vu": "1 message/minute to each of 2 joined channels", "auth_enabled_channels": "Authentication Row Level Security (RLS) enabled"}, "postgres_changes_scaling_dynamics": {"challenge": "Every change event must be checked for user access; 1 insert can trigger 100 'reads' for 100 subscribed users.", "bottleneck": "Database authorization speed can limit message throughput.", "processing_limitation": "Database changes are processed on a single thread to maintain change order; compute upgrades have limited effect.", "estimated_maximum_throughput": {"total_db_changes_per_sec": "64", "max_messages_per_client_per_sec": "64", "max_total_messages_per_sec": "32_000", "latency_p95": "238ms"}, "optimization_recommendations": ["Consider using a separate 'public' table without RLS and filters for Postgres Changes at scale.", "Alternatively, use Realtime server-side only and then re-stream the changes to clients using a Realtime Broadcast."], "general_recommendation": "Run your own benchmarks to ensure performance is acceptable for your use case."}}, "temporal_info": {}, "geographical_data": {"deployment_locations": "AWS (single-region and multi-region setups mentioned for cluster configurations)"}, "references": ["k6 (open-source load testing tool)"]}