{"extracted_information": "The document details Row Level Security (RLS) performance optimization techniques and best practices, along with methods to measure performance in Supabase applications. It addresses how RLS can significantly impact query performance, especially for operations looking at every row, and provides actionable steps to mitigate these issues.", "specifications": {"RLS_impact_areas": ["Queries that look at every row in a table (select, update)", "Queries using limit and offset (often require querying all rows to determine order)"], "Performance_measurement_tools": ["Postgres 'explain' command (for detailed query analysis and execution time comparison)", "PostgREST '.explain()' modifier (with prior DB command for non-production environments)"]}, "pricing": {}, "features": [{"name": "Index Columns Used in RLS", "description": "Add indexes to columns used in RLS policies that are not primary keys or unique already. This can lead to significant performance improvements.", "example_rls": "auth.uid() = user_id", "example_index": "create index userid on test_table using btree (user_id) tablespace pg_default;", "performance_gain": "Over 100x improvement seen on large tables (e.g., 171ms to <.1ms for auth.uid()=user_id when user_id is indexed)."}, {"name": "Wrap RLS Queries and Functions in Select Statements", "description": "Wrap functions and subqueries within RLS policies in a 'select' statement (e.g., (select auth.uid())). This allows the optimizer to run an 'initPlan' and cache results, preventing the function from being called on each row. This applies to JWT functions (auth.uid(), auth.jwt()) and security definer functions, provided the results do not change based on row data.", "example_rls_before": "is_admin() or auth.uid() = user_id", "example_rls_after": "(select is_admin()) OR (select auth.uid()) = user_id", "performance_gain": "Significant, e.g., 179ms to 9ms for auth.uid()=user_id, or 11,000ms to 7ms for is_admin()_table join."}, {"name": "Do Not Rely on RLS for Filtering", "description": "Use RLS only for security validation. Add explicit filters (e.g., '.eq()' in JS client, or 'WHERE' clause) in your application queries in addition to RLS policies. This offloads filtering to the query execution plan, which is generally more efficient.", "example_client_before": ".from('table').select() (with RLS: auth.uid() = user_id)", "example_client_after": ".from('table').select().eq('user_id',userId)", "performance_gain": "Substantial, e.g., 171ms to 9ms."}, {"name": "Use Security Definer Functions to Bypass RLS on Other Tables", "description": "Create security definer functions to perform queries on other tables that should not be subject to the RLS of those tables. This prevents nested RLS checks from slowing down complex policies. If the function returns a fixed value, consider wrapping it in a 'select' statement (Method 2).", "example_rls_before": "exists (select 1 from roles_table where auth.uid() = user_id and role = 'good_role')", "example_rls_after_with_function": "(select has_role()) (where has_role() is a security definer function)", "warning": "If the security definer function uses row information as an input, wrapping it as per method 2 might not be possible, requiring performance testing."}, {"name": "Optimize Join Queries for RLS", "description": "When an RLS policy involves joining tables, optimize the join by pre-calculating the relevant column values into an array/set and using 'IN' or 'ANY' operations. This avoids querying on a row column in the join table's WHERE clause which can be very slow. Consider moving the join query to a security definer function to avoid RLS on the join table itself.", "example_rls_slower": "auth.uid() in (select user_id from team_user where team_user.team_id = table.team_id)", "example_rls_faster": "team_id in (select team_id from team_user where user_id = auth.uid())", "example_rls_faster_with_function": "team_id in (select user_teams())", "note": "If the 'in' list exceeds ~10K items, further analysis is needed."}, {"name": "Utilize 'TO' Option or Roles Dropdown", "description": "Always specify the 'authenticated' role (or other appropriate roles) in the 'TO' policy or roles dropdown in the dashboard for RLS, instead of relying solely on 'auth.uid()' or 'auth.jwt()'. This prevents the database from processing the full RLS policy for 'anon' users, eliminating unnecessary processing overhead.", "performance_gain": "Eliminates processing for 'anon' users, improving performance for signed-in users by removing load, e.g., 170ms to <.1ms for anon accessing."}], "statistics": {"sample_results_table": [{"Test": "1", "RLS_Before": "auth.uid()=user_id", "RLS_After": "user_id indexed", "SQL_Before_ms": "171ms", "SQL_After_ms": "<.1ms"}, {"Test": "2a", "RLS_Before": "auth.uid()=user_id", "RLS_After": "(select auth.uid()) = user_id", "SQL_Before_ms": "179ms", "SQL_After_ms": "9ms"}, {"Test": "2b", "RLS_Before": "is_admin()_table join", "RLS_After": "(select is_admin())_table join", "SQL_Before_ms": "11,000ms", "SQL_After_ms": "7ms"}, {"Test": "2c", "RLS_Before": "is_admin() OR auth.uid()=user_id", "RLS_After": "(select is_admin()) OR (select auth.uid()=user_id)", "SQL_Before_ms": "11,000ms", "SQL_After_ms": "10ms"}, {"Test": "2d", "RLS_Before": "has_role()=role", "RLS_After": "(select has_role())=role", "SQL_Before_ms": "178,000ms", "SQL_After_ms": "12ms"}, {"Test": "2e", "RLS_Before": "team_id=any(user_teams())", "RLS_After": "team_id=any(array(select user_teams()))", "SQL_Before_ms": "173,000ms", "SQL_After_ms": "16ms"}, {"Test": "3", "RLS_Before": "auth.uid()=user_id", "RLS_After": "add .eq or where on user_id", "SQL_Before_ms": "171ms", "SQL_After_ms": "9ms"}, {"Test": "5", "RLS_Before": "auth.uid() in *table join on col*", "RLS_After": "col in *table join on auth.uid()*", "SQL_Before_ms": "9,000ms", "SQL_After_ms": "20ms"}, {"Test": "6", "RLS_Before": "No TO policy", "RLS_After": "TO authenticated (anon accessing)", "SQL_Before_ms": "170ms", "SQL_After_ms": "<.1ms"}], "advanced_example_results_table": [{"Policy": "=ANY(user_teams())", "Index": "no", "Main_Rows": "1M", "Team_Rows": "1000", "10_Teams_ms": ">2Min (TO or killed)", "100_Teams_ms": ">2Min (TO or killed)", "500_Teams_ms": ">2Min (TO or killed)"}, {"Policy": "=ANY(user_teams())", "Index": "yes", "Main_Rows": "1M", "Team_Rows": "1000", "10_Teams_ms": ">2Min (TO or killed)", "100_Teams_ms": ">2Min (TO or killed)", "500_Teams_ms": ">2Min (TO or killed)"}, {"Policy": "=ANY(ARRAY(select user_teams()))", "Index": "no", "Main_Rows": "1M", "Team_Rows": "1000", "10_Teams_ms": "170ms", "100_Teams_ms": "700ms", "500_Teams_ms": "3300ms"}, {"Policy": "=ANY(ARRAY(select user_teams()))", "Index": "yes", "Main_Rows": "1M", "Team_Rows": "1000", "10_Teams_ms": "2ms", "100_Teams_ms": "3ms", "500_Teams_ms": "3ms"}, {"Policy": "in(1,2,3...100)", "Index": "no", "Main_Rows": "1M", "Team_Rows": "NA", "10_Teams_ms": "130ms", "100_Teams_ms": "142ms", "500_Teams_ms": "x (baseline check)"}, {"Policy": "=ANY(ARRAY(select user_teams()))", "Index": "yes", "Main_Rows": "1M", "Team_Rows": "10K", "10_Teams_ms": "x", "100_Teams_ms": "x", "500_Teams_ms": "x (24ms on 1K teams)"}]}, "temporal_info": {"last_edited": "2025-04-04"}, "geographical_data": {}, "references": [{"title": "Stable functions do not seem to be honored in RLS in basic form", "url": "https://github.com/orgs/supabase/discussions/9311"}, {"title": "current_setting can lead to bad performance when used on RLS", "url": "https://github.com/PostgREST/postgrest-docs/issues/609"}, {"title": "RLS-Perfomance test code", "url": "https://github.com/GaryAustin1/RLS-Perfomance"}]}