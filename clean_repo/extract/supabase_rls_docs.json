{"extracted_information": "Supabase's Row Level Security (RLS) leverages PostgreSQL's native RLS capabilities to provide granular authorization rules for data. It integrates seamlessly with Supabase Auth for end-to-end user security. Policies, attached to tables, act as implicit WHERE clauses, defining data access for different operations (SELECT, INSERT, UPDATE, DELETE). Supabase maps requests to 'anon' (unauthenticated) and 'authenticated' (logged-in) Postgres roles. Helper functions like `auth.uid()` and `auth.jwt()` facilitate policy creation by accessing user ID and JWT claims, including data from `raw_app_meta_data` for authorization. Performance recommendations include indexing policy-involved columns, wrapping functions with `SELECT` for caching, adding explicit filters to client queries, using `security definer` functions for privileged operations, minimizing joins in policies, and specifying roles with the `TO` operator for efficiency. RLS can be bypassed for administrative tasks using Supabase 'Service' keys or custom Postgres roles with the 'bypass RLS' privilege. For enterprise applications, `auth.jwt()` and `raw_app_meta_data` are key for RBAC integration and enforcing multi-factor authentication (MFA) rules.", "specifications": {"rls_enabling": "Enabled per table using `enable row level security` clause. Once enabled, no data is accessible via the public `anon` key without policies.", "policy_engine": "Postgres Policies, attached to tables, executed on every table access. Functions like an implicit `WHERE` clause.", "policy_types": {"select_policies": "Defined with the `USING` clause. Controls read access.", "insert_policies": "Defined with the `WITH CHECK` clause. Ensures new rows adhere to policy constraints.", "update_policies": "Combines `USING` (determines rows to update) and `WITH CHECK` (ensures updated values adhere to constraints). If `WITH CHECK` is absent, `USING` applies to both.", "delete_policies": "Defined with the `USING` clause. Controls row deletion."}, "roles": {"anon": "Unauthenticated requests (user not logged in).", "authenticated": "Authenticated requests (user logged in).", "usage": "These are Postgres Roles, used within policies via the `TO` clause."}, "helper_functions": {"auth_uid()": "Returns the ID of the user making the request.", "auth_jwt()": "Returns the JWT of the user making the request, allowing access to `raw_app_meta_data` (for authorization data, not user-updatable) and `raw_user_meta_data` (user-updatable, not recommended for auth data).", "mfa_integration": "`auth.jwt()` can be used to check `auth.aal` (Assurance Level) for MFA enforcement."}, "views_and_rls": {"default_behavior": "Views bypass RLS by default (created with `security definer`).", "postgres_15_and_above": "`security_invoker = true` can be set on views to make them obey RLS policies for `anon` and `authenticated` roles.", "older_postgres_versions": "Protect views by revoking access from `anon`/`authenticated` roles or placing them in unexposed schemas."}, "rls_bypass_mechanisms": {"supabase_service_keys": "Special keys that bypass RLS, intended for administrative tasks, not for client-side use.", "postgres_roles_with_privilege": "New Postgres Roles can be granted the `bypass RLS` privilege for system-level access. Credentials for such roles should not be shared."}}, "pricing": {}, "features": ["Granular authorization rules using Postgres RLS.", "Flexible, allowing complex SQL rules for unique business needs.", "Integrates with Supabase Auth for end-to-end user security.", "Provides 'defense in depth' to protect data from malicious actors even via third-party tools.", "Policy rule engine simplifies access control management.", "Enables enforcement of Multi-Factor Authentication (MFA) rules within policies."], "statistics": {"performance_benchmarks": [{"recommendation": "Add indexes on policy columns", "example_policy": "`user_id = auth.uid()`", "benchmark_details": [{"test": "test1-indexed", "before_ms": 171, "after_ms": "< 0.1", "improvement_percent": "99.94%", "change": "Before: No index After: `user_id` indexed"}]}, {"recommendation": "Call functions with `select`", "example_policy": "Instead of `auth.uid() = user_id`, use `(select auth.uid()) = user_id`", "benchmark_details": [{"test": "test2a-wrappedSQL-uid()", "before_ms": 179, "after_ms": 9, "improvement_percent": "94.97%", "change": "Before: `auth.uid() = user_id` After: `(select auth.uid()) = user_id`"}, {"test": "test2b-wrappedSQL-isadmin()", "before_ms": 11000, "after_ms": 7, "improvement_percent": "99.94%", "change": "Before: `is_admin()` *table join* After: `(select is_admin())` *table join*"}, {"test": "test2c-wrappedSQL-two-functions", "before_ms": 11000, "after_ms": 10, "improvement_percent": "99.91%", "change": "Before: `is_admin() OR auth.uid() = user_id` After: `(select is_admin()) OR (select auth.uid() = user_id)`"}, {"test": "test2d-wrappedSQL-sd-fun", "before_ms": 178000, "after_ms": 12, "improvement_percent": "99.993%", "change": "Before: `has_role() = role` After: `(select has_role()) = role`"}, {"test": "test2e-wrappedSQL-sd-fun-array", "before_ms": 173000, "after_ms": 16, "improvement_percent": "99.991%", "change": "Before: `team_id=any(user_teams())` After: `team_id=any(array(select user_teams()))`"}]}, {"recommendation": "Add filters to every query", "example_policy": "Explicitly add `WHERE` clauses in client queries (e.g., `.eq('user_id', user.id)`) even if covered by policies.", "benchmark_details": [{"test": "test3-addfilter", "before_ms": 171, "after_ms": 9, "improvement_percent": "94.74%", "change": "Before: `auth.uid() = user_id` After: add `.eq` or `where` on `user_id`"}]}, {"recommendation": "Minimize joins in policies", "example_policy": "Rewrite policies to fetch filter criteria into an array/set and use `IN` or `ANY` instead of direct joins.", "benchmark_details": [{"test": "test5-fixed-join", "before_ms": 9000, "after_ms": 20, "improvement_percent": "99.78%", "change": "Before: `auth.uid()` in table join on col After: col in table join on `auth.uid()`"}]}, {"recommendation": "Specify roles in policies", "example_policy": "Use `TO authenticated` to limit policy execution to specific roles.", "benchmark_details": [{"test": "test6-To-role", "before_ms": 170, "after_ms": "< 0.1", "improvement_percent": "99.78%", "change": "Before: No `TO` policy After: `TO authenticated` (anon accessing)"}]}]}, "temporal_info": {"postgres_versions_for_views": {"postgres_15_and_above": "`security_invoker = true` option for views to obey RLS."}}, "geographical_data": {}, "references": ["https://www.postgresql.org/docs/current/ddl-rowsecurity.html (Postgres RLS documentation)", "/docs/guides/auth (Supabase Auth documentation)", "https://en.wikipedia.org/wiki/Defense_in_depth_(computing) (Defense in Depth concept)", "https://www.postgresql.org/docs/current/sql-createpolicy.html (Postgres CREATE POLICY documentation)", "/docs/guides/api (Supabase API documentation)", "/docs/guides/database/postgres/roles (Supabase Postgres Roles documentation)", "/docs/guides/auth/auth-mfa#enforce-rules-for-mfa-logins (Supabase MFA documentation)", "https://github.com/GaryAustin1/RLS-Performance (RLS Performance tests and benchmarks)", "/docs/guides/database/postgres/indexes (Supabase Postgres Indexes documentation)", "/docs/guides/database/testing (Supabase database testing guide)", "/docs/guides/database/postgres/row-level-security (Supabase RLS guide)", "https://github.com/orgs/supabase/discussions/14576 (RLS Guide and Best Practices discussion)", "https://github.com/usebasejump/supabase-test-helpers/tree/main (Community repo on testing RLS using pgTAP and dbdev)"]}